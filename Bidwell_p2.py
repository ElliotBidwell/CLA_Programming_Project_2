# Elliot Bidwell
# CS 2300-001
# Programming Project 2
from math import *
from typing import List


# This class defines the game board. It prints itself, calculates the score, keeps track of turns,
# updates itself, and checks if all of its spaces have been filled
class GameBoard:

    def __init__(self, size):
        # The length and width of the board are the same so the value is stored in a single size variable
        self.size = size
        # This 2D list is the matrix that represents the game board
        self.game_matrix = [['-' for x in range(size)] for y in range(size)]
        # This dictionary defines the players in the game and their corresponding symbols
        self.players = {
            'Player 1': 'x',
            'Player 2': 'o'
        }
        # This variable defines who is currently taking a turn, player 1 goes first
        self.current_player = self.players['Player 1']

    # This function prints the game board and the score to the console and the output file
    def print_board(self, filename):
        # Loop through each row of the matrix
        for u in range(0, len(self.game_matrix)):
            # Loop through each element in the row and print each one to the console
            for f in range(0, len(self.game_matrix)):
                print(self.game_matrix[u][f], end=" ")
            print()
        # Print the score to the console
        print(self.produce_score())

        # Create a file object by opening the output file
        output_file = open(filename, 'w', encoding="utf-8")
        # Loop through each row of the matrix
        for u in range(0, len(self.game_matrix)):
            # Loop through each element in the row and print each one to the output file
            for f in range(0, len(self.game_matrix)):
                output_file.write(f'{self.game_matrix[u][f]} ')
            output_file.write('\n')
        # Print the score to the output file
        output_file.write(self.produce_score())
        # Close the file
        output_file.close()

    # This function calculates the score and returns a formatted string
    # that denotes the current score
    def produce_score(self):
        p1_score = 0
        p2_score = 0

        # Loop through the matrix, count every occurrence of 'x', and add it to player 1's score
        for x in self.game_matrix:
            p1_score += x.count('x')

        # Loop through the matrix, count every occurrence of 'o', and add it to player 2's score
        for row in self.game_matrix:
            p2_score += row.count('o')

        return f'Score:\n    Player 1 Score: {p1_score}\n    Player 2 Score: {p2_score}\n'

    # This function alternates between which player is currently taking a turn
    def alternate_turn(self):
        if self.current_player == self.players['Player 1']:
            self.current_player = self.players['Player 2']

        elif self.current_player == self.players['Player 2']:
            self.current_player = self.players['Player 1']

    # The function takes a line in as an argument and replaces an element in the game board corresponding to the
    # end point of the line with the symbol corresponding to the current player
    def update_board(self, line):
        self.game_matrix[int(line.ep[0]) - 1][int(line.ep[1]) - 1] = self.current_player

    def check_board_full(self):
        count = 0
        for x in self.game_matrix: count += x.count('x')

        if count:
            return False
        else:
            return True


# This class defines a line in parametric form
class Line:
    # The constructor takes in arguments for the start and end points
    def __init__(self, start_point, end_point):
        # Member variables store the start and end points, the vector, the magnitude and a list for
        # the points generated by linear interpolation
        self.sp = [start_point[0], start_point[1]]
        self.ep = [end_point[0], end_point[1]]
        # Vector is calculated and stored
        self.v = [self.ep[0] - self.sp[0], self.ep[1] - self.sp[1]]
        # Magnitude is calculated and stored
        self.m = sqrt((self.v[0] ** 2) + (self.v[1] ** 2))
        self.pts_along = []

    # This function returns a string representing the parametric form of the line
    def __str__(self):
        return f'l(t) = {self.sp} + t{self.v}'

    # This function uses linear interpolation to generate a number of equally spaced points
    # equal to the value passed as an argument
    def generate_points(self, number_of_parameters):
        for i in range(0, number_of_parameters):
            point = [self.sp[0] + (i / (number_of_parameters - 1) * self.v[0]),
                     self.sp[1] + (i / (number_of_parameters - 1) * self.v[1])]
            # print(f'point at t = {i}/{number_of_parameters - 1}: {point}')
            self.pts_along.append(point)
        return self.pts_along


# This class defines a record of previously generated lines. It contains two lists. One for all previously
# generated lines and another for the last k lines. This class also has a function to check the validity
# of generated lines based on it's records
class LineRecord:  # MAY NEED TO BE MODIFIED TO SERVE THE PURPOSE OF SCOREKEEPER
    # The constructor takes in a single argument for k
    def __init__(self, k):
        # Member variables store k, the conditions of whether player 1 or 2 has made an invalid play, and
        # the two lists for the line records
        self.k = k
        self.p1_invalid = False
        self.p2_invalid = False
        self.record = []
        self.last_k = []

    # This function checks if the line being passed in is perpendicular to any of the previous lines or
    # if it's start and end points are equivalent to those of the last k lines
    def check_line_valid(self, line, xo):
        valid = True
        # This loops through all previous lines and compares their vectors to that of the passed in line
        # to check for perpendicularity. It does so using the dot product
        for record_line in self.record:
            if (line.v[0] * record_line.v[0]) + (line.v[1] * record_line.v[1]) == 0:
                print(f'{line} is perpendicular to {record_line}.\nLine not created.')
                if xo == 'x':
                    self.p1_invalid = True
                else:
                    self.p2_invalid = True
                valid = False

        # This loops through the last k lines checking if the passed in line shares any start or end points
        # with any of them
        for record_line in self.last_k:
            if (line.sp == record_line.sp) | (line.ep == record_line.ep) \
                    | (line.sp == record_line.ep) | (line.ep == record_line.sp):
                print(f'{line}, Start: {line.sp}, End: {line.ep} shares a point with {record_line}, Start:'
                      f' {record_line.sp}, End: {record_line.ep}.\nTurn invalid.')
                valid = False
        # The function ends with a call to the update function so that the passed in line can be appended to
        # the records
        self.update_record(line)
        return valid

    # This function updates the two lists of previous lines by appending the passed in line.
    # There is a check to see if the length of the list of the last k lines has exceeded k
    def update_record(self, new_line):
        self.record.append(new_line)
        self.last_k.append(new_line)

        # If the list of the last k lines has exceeded k, the least recent line is removed
        if len(self.last_k) > self.k:
            self.last_k.pop(0)

    # This function prints formatted strings of the equations and start/end points for each previous line
    def print_records(self):
        print(f'All previous lines:')
        for line in self.record:
            print(f'{line}, Start: {line.sp}, End: {line.ep}')
        print()
        print(f'Last {self.k} lines:')
        for line in self.last_k:
            print(f'{line}, Start: {line.sp}, End: {line.ep}')
        print()


# This function opens the input file of the name passed in and uses a nested for loop to populate a list
# of lists containing each value read from the input file to be returned
def get_input(filename):
    input_file = open(filename, 'r', encoding="utf-8")
    input_values = [[int(x) for x in line.split()] for line in input_file]

    return input_values


# This function takes in the game board matrix, an 'x' or 'o', and a list containing the start and
# end points for the line being played. It then uses the points to create a line object that
# simulates a line in parametric form. It then uses the several points generated by the line
# object using linear interpolation to decide how many, and which cells to test. The cell testing
# is done by examining a generated point on the line and creating a centered point in the cell above
# and below it, solving for the feet of the points, and then measuring the distance from each point
# to their corresponding feet. Then the cell corresponding to the shortest distance is set to either
# an 'x' or an 'o' depending on what was passed in. Creating the centered point above a
# point on the line is done by rounding both components of the point on the line upwards to the next
# whole number, regardless of their decimals. Making the centered point below is done the same way except
# the components are rounded downwards.
#
def take_turn(game_board, points):
    # An object is created to represent a line with the given start and end points
    line = Line(points[:2], points[2:])
    # A string representing the line's equation is generated and printed
    print(f'Line: {line}')
    print(f'Start: {line.sp} \nEnd: {line.ep}')
    print(f'Vector magnitude = {line.m}')
    # The line object generates a number of points equal to the width/height of the game board
    line.generate_points(game_board.size)

    # This loop generates line objects for the centered points above and below the points on the initial line.
    # The line objects share the same starting point as the initial line
    for i in range(len(line.pts_along)):
        # Line objects are generated. The end points of the above and below lines are calculated by rounding
        # the components of the point on the initial line up and down to the next whole number respectively
        line_above = Line(line.sp, [float(ceil(line.pts_along[i][0])), float(ceil(line.pts_along[i][1]))])
        line_below = Line(line.sp, [float(int(line.pts_along[i][0])), float(int(line.pts_along[i][1]))])

        # The parameter value along the initial line that corresponds with the above point is calculated by
        # dividing the dot product of the vectors of both lines by the magnitude squared of the initial line's vector
        parameter_above = (line.v[0] * line_above.v[0] + line.v[1] * line_above.v[1]) / line.m ** 2
        # The foot of the above point is calculated by plugging the parameter into the equation of the initial line
        foot_above = [line.v[0] * parameter_above + line.sp[0], line.v[0] * parameter_above + line.sp[0]]
        # Distance from the foot to the above point is calculated using the pythagorean theorem
        distance_above = sqrt((foot_above[0] - line.pts_along[i][0]) ** 2 + (foot_above[1] - line.pts_along[i][1]) ** 2)

        # The procedure for the point below is identical
        parameter_below = (line.v[0] * line_below.v[0] + line.v[1] * line_below.v[1]) / line.m ** 2
        foot_below = [line.v[0] * parameter_below + line.sp[0],
                      line.v[0] * parameter_below + line.sp[0]]
        distance_below = sqrt(
            (foot_below[0] - line.pts_along[i][0]) ** 2 + (foot_below[1] - line.pts_along[i][1]) ** 2)

        # Update the game board with whichever point is closest
        if distance_above <= distance_below:
            game_board.update_board(line_above)
        if distance_below < distance_above:
            game_board.update_board(line_below)


def main():
    inputs = get_input('Bidwell_inp-2.txt')
    # Create the line record object
    record = LineRecord(inputs[0][1])
    # Create the game board object
    game_board = GameBoard(inputs[0][0])
    inputs.pop(0)

    game_board.print_board('Bidwell_output-2.txt')

    for i in inputs:
        line = Line(i[:2], i[2:])
        if record.check_line_valid(line, game_board.current_player):
            take_turn(game_board, i)
        else:
            print()
        if (record.p1_invalid & record.p2_invalid) | game_board.check_board_full():
            break
        game_board.alternate_turn()
        game_board.print_board('Bidwell_output-2.txt')


main()
